<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Igor DejanoviÄ‡" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Grammars - Arpeggio</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../css/version-select.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Grammars";
        var mkdocs_page_input_path = "grammars.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
      <script async src="https://www.googletagmanager.com/gtag/js?id=UA-68681917-1"></script>
      <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', "UA-68681917-1");
      </script>
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Arpeggio
        </a>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">User Guide</span></p>
              <ul class="current">
                  <li class="toctree-l1"><a class="reference internal" href="../getting_started/">Getting started</a>
                  </li>
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">Grammars</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#grammars-written-in-python">Grammars written in Python</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#overriding-of-special-rule-classes">Overriding of special rule classes</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#grammars-written-in-peg-notations">Grammars written in PEG notations</a>
    </li>
    </ul>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../parse_trees/">Parse tree</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../handling_errors/">Handling errors</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../debugging/">Debugging</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../configuration/">Parser configuration</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../semantics/">Semantic analysis</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../troubleshooting/">Troubleshooting</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Tutorials</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/csv/">CSV</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/bibtex/">BibTex</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../tutorials/calc/">Calc</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">About</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../about/discuss/">Discuss</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../about/contributing/">Contributing</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../about/license/">License</a>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Arpeggio</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
          <li class="breadcrumb-item">User Guide</li>
      <li class="breadcrumb-item active">Grammars</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/textX/Arpeggio/edit/master/docs/grammars.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="grammars">Grammars<a class="headerlink" href="#grammars" title="Permanent link">&para;</a></h1>
<p>With grammar you teach Arpeggio how to parse your inputs.</p>
<hr />
<p>Arpeggio is based
on <a href="https://en.wikipedia.org/wiki/Parsing_expression_grammar">PEG grammars</a>. PEG
is a type of formal grammar that is given as a set of rules for recognizing
strings of the language. In a way it is similar to context-free grammars with a
very important distinction that PEG are always unambiguous. This is achieved by
making choice operator ordered. In PEGs a first choice from left to right that
matches will be used.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>More information on PEGs can be found on <a href="http://bford.info/packrat/">this page</a>.</p>
</div>
<p>PEG grammar is a set of PEG rules. PEG rules consists of parsing expressions and
can reference (call) each other.</p>
<p>Example grammar in PEG notation:</p>
<pre><code>first = 'foo' second+ EOF
second = 'bar' / 'baz'
</code></pre>
<p>In this example <code>first</code> is the root rule. This rule will match a literal string
<code>foo</code> followed by one or more <code>second</code> rule (this is a rule reference) followed
by end of input (<code>EOF</code>). <code>second</code> rule is ordered choice and will match either
<code>bar</code> or <code>baz</code> in that order.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>Arpeggio requires <code>EOF</code> rule/anchor at the end of the root rule if you
want the whole input to be consumed. If you leave out <code>EOF</code> Arpeggio will
parse as far as it can, leaving the rest of the input unprocessed, and return
without an error. So, be sure to always end your root rule sequence with
<code>EOF</code> if you want a complete parse.</p>
</div>
<p>During parsing each successfully matched rule will create a parse tree node. At
the end of parsing a complete <a href="../parse_trees/">parse tree</a> of the input will be
returned.</p>
<p>In Arpeggio each PEG rule consists of atomic parsing expression which can be:</p>
<ul>
<li>
<p><strong>terminal match rules</strong> - create
  a <a href="../parse_trees/#terminal-nodes">Terminal nodes</a>:</p>
<ul>
<li><strong>String match</strong> - a simple string that is matched literally from the
  input string.</li>
<li><strong>RegEx match</strong> - regular expression match (based on python <code>re</code> module).</li>
</ul>
</li>
<li>
<p><strong>non-terminal match rules</strong> - create
  a <a href="../parse_trees/#non-terminal-nodes">Non-terminal nodes</a>:</p>
<ul>
<li><strong>Sequence</strong> - succeeds if all parsing expressions matches at current
  location in the defined order. Matched input is consumed.</li>
<li><strong>Ordered choice</strong> - succeeds if any of the given expressions matches at
  the current location. The match is tried in the order defined. Matched
  input is consumed.</li>
<li><strong>Zero or more</strong> - given expression is matched until match is successful.
  Always succeeds. Matched input is consumed.</li>
<li><strong>One or more</strong> - given expressions is matched until match is successful.
  Succeeds if at least one match is done. Matched input is consumed.</li>
<li><strong>Optional</strong> - matches given expression but will not fail if match can't be
  done. Matched input is consumed.</li>
<li><strong>Unordered group</strong> - matches given expressions in any order. Each given
  expression must be matched exactly once. Expressions are repeatedly tried
  from left to right until any succeeds, the process is repeated ignoring
  already matched expressions, thus the behavior is deterministic. Matched
  input is consumed.</li>
<li><strong>And predicate</strong> - succeeds if given expression matches at current
  location but does not consume any input.</li>
<li><strong>Not predicate</strong> - succeeds if given expression <strong>does not</strong> match at
  current location but does not consume any input.</li>
</ul>
</li>
</ul>
<p>PEG grammars in Arpeggio may be written twofold:</p>
<ul>
<li>Using Python statements and expressions.</li>
<li>Using textual PEG syntax (currently there are two variants, see below).</li>
</ul>
<h2 id="grammars-written-in-python">Grammars written in Python<a class="headerlink" href="#grammars-written-in-python" title="Permanent link">&para;</a></h2>
<p>Canonical form of grammar specification uses Python statements and expressions.</p>
<p>Here is an example of arpeggio grammar for simple calculator:</p>
<pre><code>def number():     return _(r'\d*\.\d*|\d+')
def factor():     return Optional(["+","-"]), [number,
                          ("(", expression, ")")]
def term():       return factor, ZeroOrMore(["*","/"], factor)
def expression(): return term, ZeroOrMore(["+", "-"], term)
def calc():       return OneOrMore(expression), EOF
</code></pre>
<p>Each rule is given in the form of Python function. Python function returns data
structure that maps to PEG expressions.</p>
<ul>
<li><strong>Sequence</strong> is represented as Python tuple.</li>
<li><strong>Ordered choice</strong> is represented as Python list where each element is one
  alternative.</li>
<li><strong>One or more</strong> is represented as an instance of <code>OneOrMore</code> class.
  The parameters are treated as a containing sequence.</li>
<li><strong>Zero or more</strong> is represented as an instance of <code>ZeroOrMore</code> class.
  The parameters are treated as a containing sequence.</li>
<li><strong>Optional</strong> is represented as an instance of <code>Optional</code> class.</li>
<li><strong>Unordered group</strong> is represented as an instance of <code>UnorderedGroup</code> class.</li>
<li><strong>And predicate</strong> is represented as an instance of <code>And</code> class.</li>
<li><strong>Not predicate</strong> is represented as an instance of <code>Not</code> class.</li>
<li><strong>Literal string match</strong> is represented as string or regular expression given
  as an instance of <code>RegExMatch</code> class.</li>
<li><strong>End of string/file</strong> is recognized by the <code>EOF</code> special rule.</li>
</ul>
<p>For example, the <code>calc</code> language consists of one or more <code>expression</code> and
end of file.</p>
<p><code>factor</code> rule consists of optional <code>+</code> or <code>-</code> char matched in that order
(they are given in Python list thus ordered choice) followed by the ordered
choice of <code>number</code> rule and a sequence of <code>expression</code> rule in brackets.
This rule will match an optional sign (<code>+</code> or <code>-</code> tried in that order) after
which follows a <code>number</code> or an <code>expression</code> in brackets (tried in that
order).</p>
<p>From this description Arpeggio builds <strong>the parser model</strong>. Parser model is a
graph of parser expressions (see <a href="../debugging/#visualization">Grammar
visualization</a>).  Each node of the graph is
an instance of some of the classes described above which inherits
<code>ParserExpression</code>.</p>
<p>Parser model construction is done during parser instantiation. For example, to
instantiate <code>calc</code> parser you do the following:</p>
<pre><code class="language-python">parser = ParserPython(calc)
</code></pre>
<p>Where <code>calc</code> is the function defining the root rule of your grammar. There is no
code generation. Parser works as an interpreter for your grammar. The grammar is
used to configure Arpeggio parser to recognize your language (in this case the
<code>calc</code> language). In other words, Arpeggio interprets the parser model (your
grammar).</p>
<p>After parser construction your can call <code>parser.parse</code> to parse your input text.</p>
<pre><code class="language-python">input_expr = &quot;-(4-1)*5+(2+4.67)+5.89/(.2+7)&quot;
parse_tree = parser.parse(input_expr)
</code></pre>
<p>Arpeggio will start from the root node and traverse <em>the parser model graph</em>
consuming all matched input. When all root node branches are traversed the
parsing is done and <em>the parse tree</em> is returned.</p>
<p>You can navigate and analyze parse tree or transform it using visitor pattern to
some more usable form (see <a href="../semantics/#visitors">Semantic analysis - Visitors</a>)</p>
<h3 id="overriding-of-special-rule-classes">Overriding of special rule classes<a class="headerlink" href="#overriding-of-special-rule-classes" title="Permanent link">&para;</a></h3>
<p>As we noted above some parsing rules are mapped to Python types (<code>Sequence</code> to
a tuple, <code>OrderedChoice</code> to a list and <code>StrMatch</code> to a string). Sometimes it is
useful to override classes that will be instantiated by Arpeggio to provide
altered behavior.</p>
<p>For example, if we want to <a href="../parse_trees/#suppressing-parse-tree-nodes">suppress all string
matches</a> we can register our version
of <code>StrMatch</code> which sets <code>suppress</code> to <code>True</code>:</p>
<pre><code class="language-python">class SuppressStrMatch(StrMatch):
    suppress = True

def grammar():
    return &quot;one&quot;, &quot;two&quot;, RegExMatch(r'\d+'), &quot;three&quot;

parser = ParserPython(grammar,
                      syntax_classes={'StrMatch': SuppressStrMatch})

result = parser.parse(&quot;one two 42 three&quot;)

# Only regex will end up in the tree
assert len(result) == 1
assert result[0] == &quot;42&quot;

</code></pre>
<p>We use <code>syntax_classes</code> parameter to <code>ParserPython</code> of <code>dict</code> type where keys
are names of the original classes and values are our modified class. Now,
Arpeggio will instantiate our class whenever it encounters Python string in the
grammar.</p>
<p>This feature is, obviously, only available for grammars written in Python.</p>
<h2 id="grammars-written-in-peg-notations">Grammars written in PEG notations<a class="headerlink" href="#grammars-written-in-peg-notations" title="Permanent link">&para;</a></h2>
<p>Grammars can also be specified using PEG notation. There are actually two of
them at the moment and both notations are implemented using canonical Python
based grammars (see
modules
<a href="https://github.com/textX/Arpeggio/blob/master/arpeggio/peg.py">arpeggio.peg</a> and
<a href="https://github.com/textX/Arpeggio/blob/master/arpeggio/cleanpeg.py">arpeggio.cleanpeg</a>).</p>
<p>There are no significant differences between those two syntax. The first one use
more traditional approach using <code>&lt;-</code> for rule assignment and <code>;</code> for the rule
terminator. The second syntax (from <code>arpeggio.cleanpeg</code>) uses <code>=</code> for assignment
and does not use rule terminator. Which one you choose is totally up to you. If
your don't like any of these syntaxes you can make your own (look at
<code>arpeggio.peg</code> and <code>arpeggio.cleanpeg</code> modules as an example).</p>
<p>An example of the <code>calc</code> grammar given in PEG syntax (<code>arpeggio.cleanpeg</code>):</p>
<pre><code class="language-python">number = r'\d*\.\d*|\d+'
factor = (&quot;+&quot; / &quot;-&quot;)? (number / &quot;(&quot; expression &quot;)&quot;)
term = factor (( &quot;*&quot; / &quot;/&quot;) factor)*
expression = term ((&quot;+&quot; / &quot;-&quot;) term)*
calc = expression+ EOF
</code></pre>
<p>Each grammar rule is given as an assignment where the LHS is the rule name (e.g.
<code>number</code>) and the RHS is a PEG expression.</p>
<ul>
<li><strong>Literal string matches</strong> are given as strings (e.g. <code>"+"</code>).</li>
<li><strong>Regex matches</strong> are given as strings with prefix <code>r</code> (e.g.
  <code>r'\d*\.\d*|\d+'</code>).</li>
<li><strong>Sequence</strong> is a space separated list of expressions (e.g. <code>expression+
  EOF</code> is a sequence of two expressions).</li>
<li><strong>Ordered choice</strong> is a list of expression separated with <code>/</code> (e.g. <code>"+" /
  "-"</code>).</li>
<li><strong>Optional</strong> expression is specified by <code>?</code>operator (e.g. <code>expression?</code>) and
  matches zero or one occurrence of <em>expression</em></li>
<li><strong>Zero or more</strong> expression is specified by <code>*</code> operator (e.g. <code>(( "*" /
  "/" ) factor)*</code>).</li>
<li><strong>One of more</strong> is specified by <code>+</code> operator (e.g. <code>expression+</code>).</li>
<li><strong>Unordered group</strong> is specified by <code>#</code> operator (e.g. <code>sequence#</code>). It has
  sense only if applied to the sequence expression. Elements of the sequence are
  matched in any order.</li>
<li><strong>And predicate</strong> is specified by <code>&amp;</code> operator (e.g. <code>&amp;expression</code> - not
  used in the grammar above).</li>
<li><strong>Not predicate</strong> is specified by <code>!</code> operator (e.g. <code>!expression</code> - not
  used in the grammar above).</li>
<li>A special rule <code>EOF</code> will match end of input string.</li>
</ul>
<p>In the RHS a rule reference is a name of another rule. Parser will try to match
another rule at that location.</p>
<p>Literal string matches and regex matches follow the same rules as Python itself
would use for
single-quoted
<a href="https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals">string literals</a>,
regarding the escaping of embedded quotes, and the translation of escape
sequences. Literal string matches are treated as normal (non-raw) string
literals, and regex matches are treated as raw string literals. Triple-quoting,
and the 'r', 'u' and 'b' prefixes, are not supported â€“ note than in arpeggio PEG
grammars, all strings are Unicode, and the 'r' prefix denotes a regular
expression.</p>
<p>Creating a parser using PEG syntax is done by the class <code>ParserPEG</code> from the
<code>arpeggio.peg</code> or <code>arpeggio.cleanpeg</code> modules.</p>
<pre><code class="language-python">from arpeggio.cleanpeg import ParserPEG
parser = ParserPEG(calc_grammar, &quot;calc&quot;)
</code></pre>
<p>Where <code>calc_grammar</code> is a string with the grammar given above and the <code>"calc"</code>
is the name of the root rule of the grammar.</p>
<p>After this you get the same parser as with the <code>ParserPython</code>. There is no
difference at all so you can parse the same language.</p>
<pre><code class="language-python">input_expr = &quot;-(4-1)*5+(2+4.67)+5.89/(.2+7)&quot;
parse_tree = parser.parse(input_expr)
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Just remember that using textual PEG syntax imposes a slight overhead since
the grammar must be parsed and the parser for your language must be built by
semantic analysis of grammar parse tree.  If you plan to instantiate your
parser once and than use it many times this shall not have that much of
performance hit but if your workflow introduce instantiating parser each time
your parse some input than consider defining your grammar using Python as it
will start faster.  Nevertheless, the parsing performance will be the same in
both approach since the same code for parsing is used.</p>
</div>
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../getting_started/" class="btn btn-neutral float-left" title="Getting started"><span class="icon icon-circle-arrow-left"></span> Previous</a>
        <a href="../parse_trees/" class="btn btn-neutral float-right" title="Parse tree">Next <span class="icon icon-circle-arrow-right"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
      <p>Copyright &copy; <a href="http://www.igordejanovic.net/">Igor DejanoviÄ‡</a>.</p>
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/textX/Arpeggio" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../getting_started/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
      <span><a href="../parse_trees/" style="color: #fcfcfc">Next &raquo;</a></span>
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../js/version-select.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
